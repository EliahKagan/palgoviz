#!/usr/bin/env bash

# This script proposes, and also can be used to perform much of, a particular
# restructuring of the project. Besides documenting and making "trunk" changes,
# it should help in patching multiple feature branches. This is important
# because we have many branches, and some changes may be hard to apply just by
# merging and solving merge conflicts. The effects of this script must always
# be inspected before being committed, and some changes must be done manually.
#
# To restructure a "stable" branch -- one that is not a feature branch off a
# "trunk" that instead has been, or ought to be, restructured -- do this:
#
#  (1) Switch to the branch.
#
#  (2) Run isort, flake8, and all tests. There should be no problems yet.
#
#  (3) Run "meta/restructure full-with-nb" and inspect the results.
#
#  (4) If the "algoviz" conda environment for the restructured project is not
#      set up yet on your machine, do that. The script's output explains how.
#
#  (5) Run all tests. Ensure all three test runners we use are working.
#
#  (6) Stage the changes.
#
#  (7) Run isort (it will consoldate new "from" imports) and flake8.
#
#  (8) Inspect and run all notebooks. Fix anything broken. Though full-with-nb
#      was used, there may be manual work to do. Save notebooks if they have
#      input (code) or Markdown cell changes or important output changes.
#
#  (9) Go through all *.py files. Examine all docstrings and comments. Fix
#      outdated references and any other inaccuracies. (This and step 8 can be
#      done in either order or interleaved.)
#
# (10) If not already done, update README.md to reflect the new structure and
#      say how to open the project, run tests, and use notebooks.
#
# Then, given a "stable" branch that was restructured, and a feature branch:
#
#  (1) Switch to the feature branch.
#
#  (2) If not already done, merge from the last commit in the history of the
#      stable branch from *before* that branch was restructured.
#
#  (3) Run isort, flake8, and all tests. There should be no problems yet.
#
#  (4) Run "meta/restructure full-no-nb" and inspect the results.
#
#  (5) Inspect the results. Run all tests. Fix anything that is broken.
#
#  (6) Run isort to normalize imports. Re-run tests. All should still pass.
#
#  (7) Commit these changes (but don't push). This prepares for the merge.
#
#  (8) Merge from the stable branch.
#
#  (9) Re-run tests. Fix any problems, updating any *.py that are no longer
#      correct, due to the change in project structure. This is mainly
#      docstrings and comments in code introduced on the feature branch.
#
# (10) Commit these changes (but don't push).
#
# (11) Update *.ipynb files that weren't updated in the merge. It may help to
#      run "meta/restructure imports-with-nb" at this point. But at minimum,
#      all notebooks, even if unchanged, be re-run and inspected. Notebooks
#      have changed should be saved. Those that have not shouldn't, to avoid
#      merge conflicts when multiple feature branches are merged back in.
#
# (12) Commit and push.
#
# This script is compatible with Windows, but only if it is run from Git Bash.
#
# Before committing or even testing ANY changes to this script, it should be
# checked with ShellCheck. Running "shellcheck meta/restructure" will do this.

set -e
shopt -s failglob globstar

if [ -t 1 ]; then
    bright=$'\e[01;37m'
    reset=$'\e[0m'
else
    bright=''
    reset=''
fi

show_usage() {
    cat <<EOF
Usage:  $0 ACTION   ...where ACTION is one of:

  full-with-nb     Reorganize project. Update imports, even in notebooks.
  full-no-nb       Reorganize project. Update imports, but not in notebooks.
  imports-with-nb  Just update imports. Do this even in in noteboooks.
  imports-no-nb    Just update imports. But do not update them in notebooks.
  help             Print this message.

Suggested strategy (but it's just a suggestion):

  Use full-with-nb on the first branch to be restructured. On other branches,
  use full-no-nb; then merge the first restructured branch; then fix up the
  other notebooks, which re-running with the imports-with-nb may help with.
  Splitting up the process this way should help avoid conflicts in notebooks.
EOF
}

msg() {
    printf '%s%s: %s%s\n' "$bright" "$0" "$1" "$reset" >&2
}

err() {
    msg "error: $1"
}

die() {
    err "$1"
    exit 1
}

argdie() {
    die "$1 (try \"$0 help\")"
}

check_tooling() {
    # If sed might not support "-b", bail out as early as possible.
    sed --version | grep -qF '(GNU sed)' || die 'need sed to be GNU sed'
}

check_shared_preconditions() {
    # For all actions, we must be in the top-level repository directory.
    [ -d .git ] || die 'not in repository root'

    # And this directory must be called algoviz.
    [ "$(basename -- "$PWD")" = algoviz ] ||
        die 'current directory is not called algoviz'

    # And its parent directory must NOT be called algoviz. If the user is in
    # algoviz/algoviz by mistake, there should be no .git directory, but this
    # is simple and easy and protects against mistakes involving re-cloning.
    [ "$(basename -- "$(dirname -- "$PWD")")" != algoviz ] ||
        die 'current directory is algoviz/algoviz but we want the parent'
}

clean_for_coarse_reorganize() {
    # Remove cached Python bytecode to avoid confusion and spare the user from
    # having to do manual and error-prone deletions in trivial cases. Bytecode
    # files are regenerated automatically, so this should always be safe.
    find . -path '*/__pycache__/*.pyc' -type f -delete
    find . -name __pycache__ -type d -delete

    # If the directories we insist on making anew are empty, delete them first.
    rmdir algoviz notebooks notes tests 2>/dev/null || :
}

check_coarse_reorganize_preconditions() {
    # We will be renaming algoviz/basics to algoviz/algoviz. Check if that's
    # safe. This avoids later moving basics INTO algoviz, gives clear errors,
    # and warns about the risk of mistakenly deleting the entire repository.
    if [ -e algoviz ]; then
        if [ -d algoviz ]; then
            err 'a subdirectory "algoviz" already exists'
        else
            err 'a non-directory "algoviz" already exists'
        fi
        msg "DANGER: it's algoviz/algoviz - don't delete the wrong algoviz!"
        exit 1
    fi

    # Check if we should be able to create the other directories.
    for d in notebooks notes tests; do
        if [ -e "$d" ]; then
            if [ -d "$d" ]; then
                die "a subdirectory \"$d\" already exists"
            else
                die "a non-directory \"$d\" already exists"
            fi
        fi
    done
}

do_coarse_reorganize() {
    # Split basics/ into multiple dirs, with configs and __init__.py in place.
    git mv basics algoviz
    git mv \
        algoviz/{.flake8,.isort.cfg,.vscode,environment.yml,requirements.txt} .
    mkdir notes notebooks tests
    git mv algoviz/{*-notes.txt,*.md} notes/
    git mv algoviz/*.ipynb notebooks/
    git mv algoviz/test_* tests/
    touch {algoviz,tests}/__init__.py

    # Patch config files and newly broken module code except for imports.
    sed -bri 's/^name:[ ]+algoviz-basics\b/name: algoviz/' environment.yml
    sed -bri "s/'decorators'/'algoviz.decorators'/" algoviz/decorators.py
    sed -bri "s/'test_context'/'tests.test_context'/" tests/test_context.py
    sed -bri '
        s@\bgreetall.py\b@algoviz/greetall.py@
        s@[ ][.][.]/data/@ data/@
    ' tests/test_greetall.txt

    # Stage the fixed files and remove a config file that is no longer needed.
    git add environment.yml {algoviz,tests}/__init__.py
    git rm --quiet math/environment.yml
    git add algoviz/decorators.py tests/{test_context.py,test_greetall.txt}
}

patch_most_imports() {
    cd algoviz
    local -a module_filenames=(*)
    cd - >/dev/null

    local modules
    modules="$(IFS='|'; printf '%s' "${module_filenames[*]%.py}")"
    local front='^([ ]{4}(>>>|[.]{3}[ ]{4})[ ]+)?' # This has 2 capture groups.

    local from_re="$front"'from[ ]+('"$modules"'([.][\w.]+)?)[ ]+import\b'
    local from_sub='\1from algoviz.\3 import'

    local import_re="$front"'import[ ]+('"$modules"')[ ]*(\r?)$'
    local import_sub='\1from algoviz import \3\4'

    local sed_script="s/$from_re/$from_sub/; s/$import_re/$import_sub/"
    sed -bri "$sed_script" algoviz/**/*.py tests/**/*.{py,txt}
}

# FIXME: Needs implementation.
patch_notebook_imports() {
    msg 'warning: patching notebook imports is not yet implemented'
}

show_success() {
    cat <<'EOF'
All automated steps appear to have completed successfully.

Most changes were staged. Run "git diff --staged" to see them.

Patches to imports were not staged. Run "git diff" to see them.

From here on out, almost all use of the project should be from the root of
the repository. Editors/IDEs should open that folder. Test runners, style
checkers, and jupyter (including for JupyterLab) should be run from there.

Remember to:

1. Inspect the changes.
2. Make/use the new conda environment. Run "conda develop ." in the repo root.
3. Run all tests. Ensure the pytest, unittest, and doctest test runners work.
4. Stage. Run isort (it will consoldate new "from" imports) and flake8.
5. Check, fix up, and re-run all notebooks. Save any important changes.
6. Inspect docstrings and comments to update outdated references.
7. Update /README.md. Include how to: open project, run tests, use notebooks.
8. Merge to other branches. Manually check and fix them, even if no conflicts.
EOF
}

check_tooling

(( $# >= 1 )) || argdie "too few arguments"
(( $# <= 1 )) || argdie "too many arguments"

declare -i full nb

case "$1" in
full-with-nb)
    full=1
    nb=1
    tasks='Organize project. Fix module/doctest imports. Fix notebook imports.'
    ;;
full-no-nb)
    full=1
    nb=0
    tasks='Organize project. Fix module/doctest imports.'
    ;;
imports-with-nb)
    full=0
    nb=1
    tasks='Fix module/doctest imports. Fix notebook imports.'
    ;;
imports-no-nb)
    full=0
    nb=0
    tasks='Fix module/doctest imports.'
    ;;
help|--help|-h)
    show_usage
    exit
    ;;
*)
    argdie "unknown action \"$1\""
    ;;
esac

printf 'TASKS: %s\n\n' "$tasks"

check_shared_preconditions

if ((full)); then
    clean_for_coarse_reorganize
    check_coarse_reorganize_preconditions
    do_coarse_reorganize
fi

patch_most_imports

if ((nb)); then
    patch_notebook_imports
fi

if ((full)); then
    show_success
else
    printf 'Patching imports appears to have completed successfully.\n'
fi
