Old decorators.py doctests
==========================

    >>> from decorators import *


Old doctests for @peek_arg:

    >>> @peek_arg
    ... def square(n): return n**2
    >>> result = square(3)
    square(3)
    >>> result
    9
    >>> @peek_arg
    ... def hello(name): print(f'Hello, {name}!')
    >>> hello('Bob')
    hello('Bob')
    Hello, Bob!


Old doctests for @peek_return:

    >>> @peek_return
    ... def square(x): return x**2
    >>> result = square(3)
    square(3) -> 9
    >>> result
    9
    >>> @peek_return
    ... def hello(name): print(f'Hello, {name}!')
    >>> hello('Bob')
    Hello, Bob!
    hello('Bob') -> None


Old doctests for @call:

    >>> @call
    ... def hi():
    ...     print('Hi, world!')
    Hi, world!
    >>> hi()
    Hi, world!


Old doctests for @call_with():

    >>> @call_with('Dr. Evil', 'Albuquerque', exclaim=True)
    ... def welcome(name, place, exclaim=False):
    ...     punctuator = '!' if exclaim else '.'
    ...     print(f'Hello, {name}{punctuator} Welcome to {place}{punctuator}')
    Hello, Dr. Evil! Welcome to Albuquerque!
    >>> @call_with(*range(1, 11), verbose=True, padding=0)
    ... def print_sum(*addends, verbose, padding=1):
    ...     total = sum(addends)
    ...     if verbose:
    ...         pad = ' ' * padding
    ...         print(f'{pad}+{pad}'.join(map(str, addends)), '=', total)
    ...     else:
    ...         print(total)
    1+2+3+4+5+6+7+8+9+10 = 55
    >>> welcome('user', 'the internet')
    Hello, user. Welcome to the internet.
    >>> print_sum(-8, 2, 14, 9, verbose=False)
    17


Old doctests for @thrice:

    >>> @thrice
    ... def hello(): print('Hello, world!')
    >>> hello()
    Hello, world!
    Hello, world!
    Hello, world!
    >>> @thrice
    ... def answer(): return 42
    >>> answer()  # No output; the wrapped function always returns None.


Old doctests for @repeat:

    >>> @repeat(2)
    ... def bye():
    ...     print('Cya later!')
    >>> bye()
    Cya later!
    Cya later!


Old doctests for @peek_one:

    >>> @peek_one
    ... def square(x): return x**2
    >>> result = square(3)
    square(3)
    square(3) -> 9


Old doctests for @peek:

    >>> @peek
    ... def square(x): return x**2
    >>> result = square(3)
    square(3)
    square(3) -> 9
    >>> @peek
    ... def proclaim(*args, **kwargs):
    ...     print('Good news', *args, **kwargs)
    >>> proclaim('Hello', 'world', sep=': ', end='!\n')
    proclaim('Hello', 'world', sep=': ', end='!\n')
    Good news: Hello: world!
    proclaim('Hello', 'world', sep=': ', end='!\n') -> None


Old doctests for @memoize:

    >>> @memoize
    ... def f(n):
    ...     print(n)
    ...     return n**2
    >>> f(2)
    2
    4
    >>> f(3)
    3
    9
    >>> f(2)
    4
    >>> f(3)
    9
    >>> @memoize
    ... def g(n):
    ...     print(n)
    ...     return n**3
    >>> g(2)
    2
    8
    >>> f(2)
    4


Old doctests for @memoize_by():

    >>> @memoize_by(str.casefold)
    ... def length(text):
    ...     print(f'Computing the length of {text!r}.')
    ...     return len(text)
    >>> length('hello')
    Computing the length of 'hello'.
    5
    >>> length('Bye')
    Computing the length of 'Bye'.
    3
    >>> length('HELLO')
    5
    >>> length('bye')
    3


Old doctests for @int_fn:

    >>> @int_fn
    ... def f(n):
    ...     print(f'f({n!r})')
    ...     return n + 1
    >>> f(1)
    f(1)
    2
    >>> f(False)
    f(False)
    1
    >>> f(1.1)
    Traceback (most recent call last):
        ...
    TypeError: f must be called with int, got float
    >>> @int_fn
    ... def g(n):
    ...     return n / 2
    >>> g(4)
    Traceback (most recent call last):
        ...
    TypeError: g must return an int, returned float
    >>> g(5)
    Traceback (most recent call last):
        ...
    TypeError: g must return an int, returned float


Old doctests for @count_calls:

    >>> @count_calls
    ... def square(n): return n**2
    >>> result = square(3)
    square(3), call 1
    >>> result
    9
    >>> @count_calls
    ... def hello(name): print(f'Hello, {name}!')
    >>> hello('Bob')
    hello('Bob'), call 1
    Hello, Bob!
    >>> square(4)
    square(4), call 2
    16
    >>> hello('Bob')
    hello('Bob'), call 2
    Hello, Bob!
    >>> hello('Mary')
    hello('Mary'), call 3
    Hello, Mary!


Old doctests for @convert_arg():

    >>> @convert_arg(int)
    ... def square(n):
    ...     return n**2
    >>> square(3)
    9
    >>> square('4')
    16
    >>> square(5.1)
    25
    >>> @convert_arg(len)  # The converter can itself be any unary function.
    ... def mask(similar):
    ...     return '-' * similar
    >>> mask('hello')
    '-----'
    >>> @convert_arg(lambda s: s + 'ab')
    ... @convert_arg(str.upper)
    ... def munge1(text):
    ...     return text * 2
    >>> munge1('pqr')  # Outer converter appends, inner converter upcases.
    'PQRABPQRAB'
    >>> @convert_arg(str.upper)
    ... @convert_arg(lambda s: s + 'ab')
    ... def munge2(text):
    ...     return text * 2
    >>> munge2('pqr')  # Outer convert upcases, inner converter appends.
    'PQRabPQRab'


Old doctests for @convert_return():

    >>> @convert_return(list)
    ... def digits_lowtohigh(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_lowtohigh(4294967295)
    [5, 9, 2, 7, 6, 9, 4, 9, 2, 4]

    >>> @convert_return(lambda xs: xs[::-1])  # OK, xs will be a list.
    ... @convert_return(list)
    ... def digits_hightolow(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_hightolow(4294967295)
    [4, 2, 9, 4, 9, 6, 7, 2, 9, 5]

    >>> @convert_return(list)
    ... @convert_return(lambda xs: xs[::-1])  # NOT OK, xs will be a generator.
    ... def digits_hightolow(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_hightolow(4294967295)
    Traceback (most recent call last):
        ...
    TypeError: 'generator' object is not subscriptable

    >>> @convert_arg(int)                     # OK.
    ... @convert_return(lambda a: a[::-1])
    ... @convert_return(list)
    ... def digits_hightolow(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_hightolow(4294967295.3)
    [4, 2, 9, 4, 9, 6, 7, 2, 9, 5]

    >>> @convert_return(lambda a: a[::-1])
    ... @convert_return(list)
    ... @convert_arg(int)                     # OK.
    ... def digits_hightolow(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_hightolow(4294967295.3)
    [4, 2, 9, 4, 9, 6, 7, 2, 9, 5]

    >>> @convert_return(lambda a: a[::-1])
    ... @convert_arg(int)                     # Weird, but OK.
    ... @convert_return(list)
    ... def digits_hightolow(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_hightolow(4294967295.3)
    [4, 2, 9, 4, 9, 6, 7, 2, 9, 5]

    >>> @convert_return(list)
    ... @convert_arg(int)
    ... @convert_return(lambda a: a[::-1])    # NOT OK, xs will be a generator.
    ... def digits_hightolow(positive_integer):
    ...     while positive_integer != 0:
    ...         yield positive_integer % 10
    ...         positive_integer //= 10
    >>> digits_hightolow(4294967295.3)
    Traceback (most recent call last):
        ...
    TypeError: 'generator' object is not subscriptable


Old doctests for @auto_prime:

    >>> import collections, inspect
    >>> @auto_prime
    ... def alternate_ends(iterable, *, back_first=False):
    ...     pool = collections.deque(iterable)
    ...     yield  # The caller receives a generator primed to here.
    ...     if pool and back_first: yield pool.pop()
    ...     while pool:
    ...         yield pool.popleft()
    ...         if pool: yield pool.pop()

    >>> it = alternate_ends(range(1, 6))
    >>> inspect.getgeneratorstate(it)  # GEN_SUSPENDED instead of GEN_CREATED.
    'GEN_SUSPENDED'
    >>> list(it)
    [1, 5, 2, 4, 3]
    >>> list(alternate_ends(range(1, 6), back_first=True))
    [5, 1, 4, 2, 3]
    >>> alternate_ends(10 // i for i in range(3, -1, -1))  # Fails fast.
    Traceback (most recent call last):
      ...
    ZeroDivisionError: integer division or modulo by zero

    >>> @auto_prime
    ... def first_yield_non_none(values):
    ...     while values: yield values.pop()
    >>> a = [10, 20, 30]
    >>> first_yield_non_none(a)
    Traceback (most recent call last):
      ...
    TypeError: generator yielded non-None value when primed
    >>> a
    [10, 20]


Old doctests for @dict_equality:

    >>> @dict_equality
    ... class Point:
    ...     def __init__(self, x, y):
    ...         self.x = x
    ...         self.y = y
    ...     def __repr__(self):
    ...         return f'{type(self).__name__}({self.x!r}, {self.y!r})'
    >>> Point(1, 2) == Point(1, 2) == Point(1.0, 2.0) != Point(2, 1)
    True
    >>> {Point(1, 2), Point(1, 2)}
    {Point(1, 2)}

    >>> @dict_equality
    ... class Weird:
    ...     __slots__ = ('a', 'b', '__dict__')
    ...     def __init__(self, a, b, c):
    ...         self.a = a
    ...         self.b = b
    ...         self.c = c
    >>> Weird(1, 2, 3) == Weird(4, 5, 3) != Weird(4, 5, 6)
    True

    >>> class Base:
    ...     def __init__(self, x, y):
    ...         self.x = x
    ...         self.y = y
    >>> @dict_equality
    ... class Derived(Base): pass
    >>> class MoreDerived(Derived): pass
    >>> Base(1, 2) == Derived(1, 2), Derived(1, 2) == Base(1, 2)
    (False, False)
    >>> Derived(1, 2) == MoreDerived(1, 2), MoreDerived(1, 2) == Derived(1, 2)
    (True, True)

    >>> @dict_equality
    ... class A: pass
    >>> @dict_equality
    ... class B: pass
    >>> class C: pass
    >>> A() == A(), A() == B(), B() == A(), A() == C(), C() == A()
    (True, False, False, False, False)


Old doctests for @joining():

    >>> @joining(use_repr=True, begin='[', end=']')
    ... def f(n): return (ch * n for ch in 'ABC')
    >>> f(3)
    "['AAA', 'BBB', 'CCC']"
    >>> @joining('; ', format_spec='.2f')
    ... def g(a, b, *, delta=1):
    ...     while a < b:
    ...         yield a
    ...         a += delta
    >>> g(1.7, 6.4, delta=1.15)
    '1.70; 2.85; 4.00; 5.15; 6.30'

    When keeping all defaults, it can also be used directly as a decorator:

    >>> @joining
    ... def g(start, stop):
    ...     while start > stop:
    ...         yield start
    ...         start /= 2
    >>> g(7, 0.5)
    '7, 3.5, 1.75, 0.875'
